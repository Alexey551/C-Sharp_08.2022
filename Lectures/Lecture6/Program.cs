/*

По-настоящему красивый код
Хороший код:
● гибкий,
● расширяемый,
● модульный,
● поддерживаемый,
● документируемый.4

Гибкость
Здорово, если функционал одного модуля можно использовать несколько раз.
Допустим, вы написали метод заполнения массива числами. Если это массив целых чисел, туда можно
положить только целые числа. Если массив double, вещественные числа. А что, если в качестве данных,
которые нужно будет получить, у вас будут строки? Или котики, и нужно будет вернуть массив
котиков? Хорошо, если система заранее построена так, что код можно переиспользовать.
При этом важно не пытаться всё обобщать. Писать код, который можно переиспользовать — хорошо.
Но писать код, который будет исключительно общим, — так себе правило.
Может возникнуть когнитивный диссонанс: как писать код, который, с одной стороны, можно
переиспользовать, и который, с другой стороны, должен решать конкретную задачу? Всё приходит с
опытом. Со временем вы начнёте понимать, в какой задаче можно выделить общую логику, а в какой
лучше использовать что-то конкретное.

Расширяемость
Хорошо, если вы спроектировали систему так, что в неё можно будет добавить новые модули.
Представим, что мы пишем мессенджер. Сегодня в нём можно принимать и отправлять сообщения
только одному пользователю. Завтра мы захотим добавить групповые чаты. Сложно ли это? Если
система изначально задумана так, что в чате могут находиться только две условные единицы (два
пользователя), придётся писать её заново. Но ведь мы могли изначально продумать систему так, что в
чате может быть сколько угодно пользователей. Просто в первой версии в ней могло бы находиться
два человека, а дальше мы бы доделывали функционал.
Другой пример: изначально в нашем мессенджере можно было отправлять только текстовые
сообщения, но мы решили добавить возможность отправлять картинки. Сильно ли они отличаются от
песни или голосового сообщения? И то, и то — файл. Поэтому нам нужно было бы описать метод,
который отправляет файл. А в качестве файла могут быть картинки, песни, звуки, видео, анимации и
так далее.

Модульность
Представим, что мы написали мессенджер, который может отправлять картинки, но система отправки
работает очень медленно. Как сделать лучше?
Плохо, если придётся переписывать весь мессенджер. Мы изначально могли спроектировать систему
так, чтобы можно было вытащить один модуль, который отвечает за отправку картинок, и переписать5
его, возможно, привлекая более опытных разработчиков. Как следствие, заменили бы модуль
отправки картинок на новый, который работает лучше. Но это возможно только в том случае, если при
написании системы мы заранее помнили об этом.

Поддерживаемость
После того как вы выкатили первую релизную версию продукта, скорее всего, какое-то время оно
будет работать. Но после выхода очередного обновления что-то может сломаться, даже если раньше
работало хорошо. И здорово, если кроме человека, который занимался этим модулем, в команде есть
кто-то, кто может его починить.
Может быть веселее: вы, как заказчик, заказали продукт у компании-исполнителя. И после окончания
разработки, исполнители передали вам исходный код, а вы наняли команду поддержки, которая
сможет в этом коде разобраться и фиксить возникающие баги.

Документируемость
Я считаю, что документация должна быть. Но есть те, кто говорит, что код должен быть
самодокументируемым (и если это не так, то код плохой). Могу и согласиться с этим мнением, и не
согласиться. Почему — обсудим позже.

Принцип don’t repeat yourself
Когда вы копипастите, вы нарушаете один из принципов разработки — don’t repeat yourself. Его вы
должны придерживаться всегда и везде. Если вы копипастите, вы делаете неправильно. Нужно10
остановиться и подумать, как этого избежать, вынести в отдельный модуль или создать какую-то
специальную сущность.

Принцип YAGNI
Не нужно делать то, о чём вас не
просили. Это ещё один принцип разработки — YAGNI (you aren’t gonna need it — вам это не
понадобится): не делайте то, о чём вас не просят, не пытайтесь проявлять инициативу, потому что,
скорее всего, окажется только хуже.

Принцип KISS
KISS (keep it simple, stupid). 
Его суть в том, что не нужно делать что-то сложное, если можно сделать в разы проще.
Чем проще ваша система, тем легче её поддерживать и расширять. Тем легче в ней находить баги,
писать тесты и так далее. Помните о том, что нужно описывать методы максимально просто, но в
общем случае методы дальше компонуются в какие-то отдельные классы. Будь то структуры или
какие-то иные системы, единицы.

Пишем парсинг входной строки
Основные принципы мы узнали, теперь напишем парсинг входной строки.
Есть строка, в которой находятся парные координаты точек фигуры.
Наша задача — увеличить каждую из координат в два раза и показать пользователю ответ.
Можно описать метод, который сначала будет разбивать пары в скобках. Затем, описав отдельный
метод, взять каждую пару (то есть точку с координатой X и координатой Y), и увеличить значение
каждой координаты с помощью ещё одного метода.
*/
using System.Linq;

string text = "(1,2) (2,3) (4,5) (6,7)"                                    // возьмите текст
              .Replace("(", "")                                            // замените в нём скобки
              .Replace(")", "")
              ;
Console.WriteLine(text);
var data = text.Split(" ")                                                 // разбейте текст с учётом разделителя (в нашем случае — пробела)
                .Select(item => item.Split(','))                           // сделайте выборку item, для которых нужно взять отдельную подстроку и разбить её на несколько элементов с учётом разделителя-запятой
                .Select(e => (x: int.Parse(e[0]), y: int.Parse(e[1])))     // сделайте выборку из текущего массива, чтобы первой координатой был первый элемент массива (сразу конвертированный в число). То же — со второй
                .Where(e => e.x % 2 == 0)                                  // дайте такие пары, для которых первая координата — чётная
                .Select(point => (point.x * 10, point.y))                  // дайте набор, который мы получили на предыдущем этапе, и увеличьте первую координату
                .ToArray();                                                // превратите в явный массив

for (int i = 0; i < data.Length; i++)                                      // используйте в цикле с известными вам свойствами и функционалом
{
    Console.WriteLine(data[i]);
    Console.WriteLine();
}

/*
Нотации
Осталось напомнить, что есть разные нотации, которые хорошо бы использовать, когда вы описываете
свой код. Среди них: венгерская, Pascal, CamelСase и другие, о которых обычно договаривается
команда перед разработкой очередного продукта.


Принципы разработки
- Старайтесь придерживаться принципов (Code Convention), которые оговорили с командой. 
- Пишите комментарии. 
- Производите внутреннюю декомпозицию. Это справедливо и для отдельных методов, и для больших
сущностей: классов, структур, записей и так далее. Чем меньше единица, которую вы используете, тем
лучше. Тем проще её понять, переписать, заменить и так далее.
- Чем больше у вас методов, тем лучше, потому что вы уже знаете, для чего нужна декомпозиция.
- Чем больше вы используете циклов, тем хуже ваш код. Когда вы начинаете писать цикл внутри
цикла, внутри цикла, внутри цикла, — это маркер того, что ваш код будет работать очень медленно.
- Если вы пишете, какой-то метод, для него сразу должен быть тест. 
- Пользовательские данные — на каждом этапе важно следить за тем, что вам подсовывает
пользователь, как-то это обрабатывать. 
- И главный вопрос, который я рекомендую задавать на каждом этапе разработки, после каждого
написанного метода, — можно ли сделать лучше и проще? Пожалуйста, почаще задавайте себе этот
вопрос, тогда ваш код станет более читаемым, более простым.

Итоги
Есть принципы, которых нужно придерживаться при разработке:
● Придерживаться SOLID
● Не использовать антипаттены
● Использовать паттерны
● Декомпозировать
● Писать тесты
● Придерживаться Сode Сonvention
*/